
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openPermissionSettings(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("open_permission_settings", { permission });
},
async requestPermission(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("request_permission", { permission });
},
/**
 * Reset a permission using tccutil and re-request it
 * This removes the app from the TCC database and triggers a fresh permission request
 */
async resetAndRequestPermission(permission: OSPermission) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_and_request_permission", { permission }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async doPermissionsCheck(initialCheck: boolean) : Promise<OSPermissionsCheck> {
    return await TAURI_INVOKE("do_permissions_check", { initialCheck });
},
/**
 * Check only microphone permission (no screen recording check)
 * Use this for polling to avoid triggering macOS screen capture permission dialogs
 */
async checkMicrophonePermission() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_microphone_permission");
},
/**
 * Check only accessibility permission
 * Use this for polling to check if user has granted accessibility permission
 */
async checkAccessibilityPermissionCmd() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_accessibility_permission_cmd");
},
/**
 * Check if Arc browser is installed (macOS only)
 */
async checkArcInstalled() : Promise<boolean> {
    return await TAURI_INVOKE("check_arc_installed");
},
/**
 * Check if Automation permission for Arc is already granted.
 * In production (.app bundle): uses direct FFI check (correct identity, no Terminal).
 * In dev mode: runs the binary itself via launchctl (detached from Terminal) so
 * macOS TCC checks the binary's own identity, not Terminal's.
 */
async checkArcAutomationPermission() : Promise<boolean> {
    return await TAURI_INVOKE("check_arc_automation_permission");
},
/**
 * Request macOS Automation permission for Arc browser.
 * In production: triggers "screenpipe wants to control Arc" prompt via direct FFI.
 * In dev mode: runs the binary itself via launchctl to trigger the prompt with
 * the correct binary identity (not Terminal's). Also opens System Settings as fallback.
 */
async requestArcAutomationPermission() : Promise<boolean> {
    return await TAURI_INVOKE("request_arc_automation_permission");
},
async getEnv(name: string) : Promise<string> {
    return await TAURI_INVOKE("get_env", { name });
},
async getLogFiles() : Promise<Result<LogFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMediaFile(filePath: string) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_media_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async uploadFileToS3(filePath: string, signedUrl: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upload_file_to_s3", { filePath, signedUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateGlobalShortcuts(showShortcut: string, startShortcut: string, stopShortcut: string, startAudioShortcut: string, stopAudioShortcut: string, profileShortcuts: { [key in string]: string }) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_global_shortcuts", { showShortcut, startShortcut, stopShortcut, startAudioShortcut, stopAudioShortcut, profileShortcuts }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async spawnScreenpipe(overrideArgs: string[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_screenpipe", { overrideArgs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopScreenpipe() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_screenpipe") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMonitors() : Promise<Result<MonitorDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_monitors") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioDevices() : Promise<Result<AudioDeviceInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isEnterpriseBuildCmd() : Promise<boolean> {
    return await TAURI_INVOKE("is_enterprise_build_cmd");
},
async getDiskUsage(forceRefresh: boolean | null) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_disk_usage", { forceRefresh }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPipeWindow(port: number, title: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_pipe_window", { port, title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateShowScreenpipeShortcut(newShortcut: string, enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_show_screenpipe_shortcut", { newShortcut, enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open the screenpi.pe login page.
 * On Windows, opens in the system browser (WebView2 has issues with some auth
 * providers; the registered deep-link scheme handles the redirect back).
 * On macOS/Linux, uses an in-app WebView that intercepts the screenpipe://
 * deep-link redirect (Safari blocks custom-scheme redirects).
 */
async openLoginWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_login_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Open Google Calendar OAuth inside an in-app WebView.
 * Same pattern as `open_login_window` — intercepts the screenpipe:// deep-link
 * redirect so we don't rely on Safari custom-scheme support.
 */
async openGoogleCalendarAuthWindow(authUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_google_calendar_auth_window", { authUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Re-assert the WKWebView as first responder for the current key panel.
 * Called from JS on pointer enter / window focus to ensure trackpad pinch
 * gestures (magnifyWithEvent:) reach the WKWebView for zoom handling.
 */
async ensureWebviewFocus() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ensure_webview_focus") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Hide the Main panel so the next shortcut press reconfigures it for the new mode.
 */
async resetMainWindow() : Promise<void> {
    await TAURI_INVOKE("reset_main_window");
},
async setWindowSize(window: ShowRewindWindow, width: number, height: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_window_size", { window, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOnboardingStatus() : Promise<Result<OnboardingStore, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_onboarding_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async completeOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setOnboardingStep(step: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_onboarding_step", { step }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showOnboardingWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_onboarding_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openSearchWindow(query: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_search_window", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showShortcutReminder(shortcut: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_shortcut_reminder", { shortcut }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hideShortcutReminder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hide_shortcut_reminder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showNotificationPanel(payload: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_notification_panel", { payload }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hideNotificationPanel() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hide_notification_panel") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register window-specific shortcuts (Escape, search shortcut) when main window is visible
 * These should only be active when the overlay is open to avoid blocking other apps
 */
async registerWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unregister window-specific shortcuts when main window is hidden.
 * Only unregisters Escape and arrow keys. Global shortcuts (search, show, chat)
 * are NOT touched here — they must persist across window show/hide cycles.
 */
async unregisterWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unregister_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Copy a frame image to the system clipboard (native API, works in Tauri webview).
 * Fetches the frame from the local server and uses arboard for clipboard access.
 */
async copyFrameToClipboard(frameId: bigint) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_frame_to_clipboard", { frameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Copy a frame deeplink (screenpipe://frame/N) to clipboard. Native API only.
 */
async copyDeeplinkToClipboard(frameId: bigint) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_deeplink_to_clipboard", { frameId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Copy arbitrary text to the system clipboard (native API, works in Tauri webview).
 * Use this instead of navigator.clipboard.writeText() which fails after async operations.
 */
async copyTextToClipboard(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("copy_text_to_clipboard", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Install a specific older version from R2. Downloads and installs via Tauri updater,
 * then restarts the app.
 */
async rollbackToVersion(version: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rollback_to_version", { version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setTrayUnhealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_unhealth_icon");
},
async setTrayHealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_health_icon");
},
async writeBrowserLog(level: string, message: string) : Promise<void> {
    await TAURI_INVOKE("write_browser_log", { level, message });
},
async writeBrowserLogs(entries: BrowserLogEntry[]) : Promise<void> {
    await TAURI_INVOKE("write_browser_logs", { entries });
},
/**
 * Get current sync status.
 */
async getSyncStatus() : Promise<Result<SyncStatusResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Enable or disable sync.
 */
async setSyncEnabled(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_sync_enabled", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Trigger an immediate sync via the screenpipe server.
 */
async triggerSync() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get sync configuration.
 */
async getSyncConfig() : Promise<Result<SyncConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update sync configuration.
 */
async updateSyncConfig(config: SyncConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_sync_config", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of registered devices.
 */
async getSyncDevices() : Promise<Result<SyncDeviceInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a device from sync.
 */
async removeSyncDevice(deviceId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_sync_device", { deviceId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize sync with password.
 * This initializes both the local SyncManager (for device queries) and
 * the server's SyncService (for actual data sync).
 */
async initSync(password: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_sync", { password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lock sync (clear keys from memory and stop server sync service).
 */
async lockSync() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("lock_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete all cloud data.
 */
async deleteCloudData() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_cloud_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get Pi info
 */
async piInfo(sessionId: string | null) : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_info", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the Pi sidecar in RPC mode (Tauri command wrapper)
 */
async piStart(sessionId: string | null, projectDir: string, userToken: string | null, providerConfig: PiProviderConfig | null) : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_start", { sessionId, projectDir, userToken, providerConfig }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the Pi sidecar
 */
async piStop(sessionId: string | null) : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_stop", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if pi is available
 */
async piCheck() : Promise<Result<PiCheckResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Install pi via bun
 */
async piInstall() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_install") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a prompt to Pi, optionally with images
 */
async piPrompt(sessionId: string | null, message: string, images: PiImageContent[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_prompt", { sessionId, message, images }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort current Pi operation
 */
async piAbort(sessionId: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_abort", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new Pi session (clears conversation history)
 */
async piNewSession(sessionId: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_new_session", { sessionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update Pi config and restart the chat session so the new model takes effect.
 * Without restart, Pi keeps using the provider/model from its original CLI args.
 */
async piUpdateConfig(userToken: string | null, providerConfig: PiProviderConfig | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_update_config", { userToken, providerConfig }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check Reminders authorization + scheduler status (no popup).
 */
async remindersStatus() : Promise<Result<RemindersStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Request Reminders permission (shows one-time macOS popup).
 * Returns "granted", "denied", or an error message.
 */
async remindersAuthorize() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_authorize") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List existing reminders in the "Screenpipe" list.
 */
async remindersList() : Promise<Result<ReminderItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a single reminder.
 */
async remindersCreate(title: string, notes: string | null, due: string | null) : Promise<Result<ReminderItem, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_create", { title, notes, due }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan recent activity and create reminders from action items.
 * Optional custom_prompt appended to the AI instructions.
 */
async remindersScan(customPrompt: string | null, audioOnly: boolean | null) : Promise<Result<ScanResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_scan", { customPrompt, audioOnly }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the background scheduler (30-min interval). Persists across page navigation.
 * Saves enabled=true to persistent store so it auto-starts on app relaunch.
 */
async remindersStartScheduler() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_start_scheduler") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the background scheduler. Saves enabled=false to persistent store.
 */
async remindersStopScheduler() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_stop_scheduler") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the saved custom prompt.
 */
async remindersGetCustomPrompt() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_get_custom_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a custom prompt.
 */
async remindersSetCustomPrompt(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_set_custom_prompt", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the audio_only setting.
 */
async remindersGetAudioOnly() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_get_audio_only") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the audio_only setting.
 */
async remindersSetAudioOnly(audioOnly: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_set_audio_only", { audioOnly }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check Calendar authorization status (no popup).
 */
async calendarStatus() : Promise<Result<CalendarStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("calendar_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Request Calendar permission (shows one-time macOS popup).
 * Returns "granted", "denied", or an error message.
 */
async calendarAuthorize() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("calendar_authorize") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get calendar events in a time window.
 */
async calendarGetEvents(hoursBack: bigint | null, hoursAhead: bigint | null) : Promise<Result<CalendarEventItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("calendar_get_events", { hoursBack, hoursAhead }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get events happening right now.
 */
async calendarGetCurrentMeeting() : Promise<Result<CalendarEventItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("calendar_get_current_meeting") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async icsCalendarGetEntries() : Promise<Result<IcsCalendarEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ics_calendar_get_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async icsCalendarSaveEntries(entries: IcsCalendarEntry[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ics_calendar_save_entries", { entries }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async icsCalendarTestUrl(url: string) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ics_calendar_test_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async icsCalendarGetUpcoming() : Promise<Result<CalendarEventItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("ics_calendar_get_upcoming") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: start voice training. Spawns a background task that polls
 * until audio is transcribed, then assigns the speaker. Returns immediately.
 */
async trainVoice(name: string, startTime: string, endTime: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("train_voice", { name, startTime, endTime }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Return cached suggestions or default idle suggestions if cache is empty.
 */
async getCachedSuggestions() : Promise<Result<CachedSuggestions, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cached_suggestions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: validate that a path is usable as a data directory.
 * Called from the frontend before saving the setting.
 */
async validateDataDir(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_data_dir", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHardwareCapability() : Promise<HardwareCapability> {
    return await TAURI_INVOKE("get_hardware_capability");
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AIPreset = { id: string; prompt: string; provider: AIProviderType; url?: string; model?: string; defaultPreset: boolean; apiKey: string | null; maxContextChars: number }
export type AIProviderType = "openai" | "native-ollama" | "custom" | "screenpipe-cloud" | "pi"
export type AudioDeviceInfo = { name: string; isDefault: boolean }
export type BrowserLogEntry = { level: string; message: string }
export type CachedSuggestions = { suggestions: Suggestion[]; generatedAt: string; mode: string; aiGenerated: boolean; tags: string[] }
export type CalendarEventItem = { id: string; title: string; 
/**
 * RFC3339 in UTC — for meeting detection / comparisons.
 */
start: string; 
/**
 * RFC3339 in UTC — for meeting detection / comparisons.
 */
end: string; 
/**
 * Pre-formatted local time, e.g. "3:30 PM" — for display.
 */
startDisplay: string; 
/**
 * Pre-formatted local time, e.g. "5:00 PM" — for display.
 */
endDisplay: string; attendees: string[]; location: string | null; calendarName: string; isAllDay: boolean }
export type CalendarStatus = { available: boolean; authorized: boolean; authorizationStatus: string; calendarCount: number }
export type Credits = { amount: number }
export type EmbeddedLLM = { enabled: boolean; model: string; port: number }
export type HardwareCapability = { hasGpu: boolean; cpuCores: bigint; totalMemoryGb: number; isWeakForLargeModel: boolean; recommendedEngine: string; reason: string }
export type IcsCalendarEntry = { name: string; url: string; enabled: boolean }
export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }
export type LogFile = { name: string; path: string; modified_at: bigint }
export type MonitorDevice = { id: number; stableId: string; name: string; isDefault: boolean; width: number; height: number }
export type OSPermission = "screenRecording" | "microphone" | "accessibility" | "automation"
export type OSPermissionStatus = "notNeeded" | "empty" | "granted" | "denied"
export type OSPermissionsCheck = { screenRecording: OSPermissionStatus; microphone: OSPermissionStatus; accessibility: OSPermissionStatus }
export type OnboardingStore = { isCompleted: boolean; completedAt: string | null; 
/**
 * Current step in onboarding flow (login, intro, usecases, status)
 * Used to resume after app restart (e.g., after granting permissions)
 */
currentStep?: string | null }
export type PiCheckResult = { available: boolean; path: string | null }
/**
 * Image content for Pi RPC protocol (pi-ai ImageContent format)
 */
export type PiImageContent = { type: string; mimeType: string; data: string }
export type PiInfo = { running: boolean; projectDir: string | null; pid: number | null; sessionId: string | null }
/**
 * Configuration for which AI provider Pi should use
 */
export type PiProviderConfig = { 
/**
 * Provider type: "openai", "native-ollama", "custom", "screenpipe-cloud"
 */
provider: string; 
/**
 * Base URL for the provider API
 */
url: string; 
/**
 * Model ID to use
 */
model: string; 
/**
 * Optional API key for the provider
 */
apiKey: string | null }
export type ReminderItem = { identifier: string; title: string; notes: string | null; completed: boolean }
export type RemindersStatus = { available: boolean; authorized: boolean; authorizationStatus: string; schedulerRunning: boolean; reminderCount: number }
export type ScanResult = { remindersCreated: bigint; items: ReminderItem[]; contextChars: bigint; error: string | null }
export type SettingsStore = 
/**
 * Catch-all for fields added by the frontend (e.g. chatHistory, deviceId)
 * that the Rust struct doesn't know about. Without this, `save()` would
 * serialize only known fields and silently wipe frontend-only data.
 */
({ [key in string]: null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue } }) & { aiPresets: AIPreset[]; deepgramApiKey: string; isLoading: boolean; userId: string; 
/**
 * Persistent analytics ID used for PostHog tracking (both frontend and backend)
 */
analyticsId: string; devMode: boolean; audioTranscriptionEngine: string; ocrEngine: string; monitorIds: string[]; audioDevices: string[]; 
/**
 * When true, automatically follow system default audio devices
 */
useSystemDefaultAudio?: boolean; usePiiRemoval: boolean; port: number; dataDir: string; disableAudio: boolean; ignoredWindows: string[]; includedWindows: string[]; ignoredUrls?: string[]; fps: number; vadSensitivity: string; analyticsEnabled: boolean; audioChunkDuration: number; useChineseMirror: boolean; languages: string[]; embeddedLLM: EmbeddedLLM; autoStartEnabled: boolean; platform: string; disabledShortcuts: string[]; user: User; showScreenpipeShortcut: string; startRecordingShortcut: string; stopRecordingShortcut: string; startAudioShortcut: string; stopAudioShortcut: string; showChatShortcut: string; searchShortcut: string; realtimeAudioTranscriptionEngine: string; disableVision: boolean; 
/**
 * When true, screen capture continues but OCR text extraction is skipped.
 * Reduces CPU usage significantly while still recording video.
 */
disableOcr?: boolean; useAllMonitors: boolean; adaptiveFps?: boolean; showShortcutOverlay?: boolean; 
/**
 * Unique device ID for AI usage tracking (generated on first launch)
 */
deviceId?: string; 
/**
 * Enable input event capture (keyboard, mouse, clipboard).
 * Requires input monitoring permission on macOS.
 */
enableInputCapture?: boolean; 
/**
 * Enable accessibility text capture (AX tree walker).
 * Requires accessibility permission on macOS.
 */
enableAccessibility?: boolean; 
/**
 * Auto-install updates and restart when a new version is available.
 * When disabled, users must click "update now" in the tray menu.
 */
autoUpdate?: boolean; 
/**
 * Timeline overlay mode: "fullscreen" (floating panel above everything) or
 * "window" (normal resizable window with title bar).
 */
overlayMode?: string; 
/**
 * Allow screen recording apps to capture the overlay.
 * Disabled by default so the overlay doesn't appear in screenpipe's own recordings.
 */
showOverlayInScreenRecording?: boolean; 
/**
 * Video quality preset controlling storage vs quality tradeoff.
 * Affects H.265 CRF during recording and JPEG quality during frame extraction.
 * Values: "low", "balanced", "high", "max". Default: "balanced".
 */
videoQuality?: string }
export type ShowRewindWindow = "Main" | { Settings: { page: string | null } } | { Search: { query: string | null } } | "Onboarding" | "Chat" | "PermissionRecovery"
export type Suggestion = { text: string }
/**
 * Sync configuration.
 */
export type SyncConfig = { enabled: boolean; syncIntervalMinutes: number; syncTranscripts: boolean; syncOcr: boolean; syncAudio: boolean; syncFrames: boolean }
/**
 * Device information.
 */
export type SyncDeviceInfo = { id: string; deviceId: string; deviceName: string | null; deviceOs: string; lastSyncAt: string | null; createdAt: string; isCurrent: boolean }
/**
 * Sync status response.
 */
export type SyncStatusResponse = { enabled: boolean; isSyncing: boolean; lastSync: string | null; lastError: string | null; storageUsed: bigint | null; storageLimit: bigint | null; deviceCount: number | null; deviceLimit: number | null; syncTier: string | null; machineId: string }
export type User = { id: string | null; name: string | null; email: string | null; image: string | null; token: string | null; clerk_id: string | null; api_key: string | null; credits: Credits | null; stripe_connected: boolean | null; stripe_account_status: string | null; github_username: string | null; bio: string | null; website: string | null; contact: string | null; cloud_subscribed: boolean | null; credits_balance: number | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
