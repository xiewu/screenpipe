"use client";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import { Toaster } from "@/components/ui/toaster";
import { useEffect } from "react";
import { DeeplinkHandler } from "@/components/deeplink-handler";
import { ShortcutTracker } from "@/components/shortcut-reminder";
import { usePathname } from "next/navigation";

const inter = Inter({ subsets: ["latin"] });

// Debounced localStorage writer
const createDebouncer = (wait: number) => {
  let timeout: NodeJS.Timeout;
  return (fn: Function) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(), wait);
  };
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const pathname = usePathname();
  const isOverlay = pathname === "/shortcut-reminder";

  useEffect(() => {
    if (typeof window === "undefined") return;

    // Patch Tauri event listener race condition (APP-2/5/9/W, 69 users)
    // Tauri's unregisterListener doesn't null-check listeners[eventId]
    // causing TypeError when unlisten is called on already-removed listener
    try {
      const internals = (window as any).__TAURI_EVENT_PLUGIN_INTERNALS__;
      if (internals?.unregisterListener) {
        const original = internals.unregisterListener;
        internals.unregisterListener = function(event: string, eventId: number) {
          try {
            return original(event, eventId);
          } catch {
            // listener already removed — race condition, ignore
          }
        };
      }
    } catch {}

    // Focus recovery for Tauri WKWebView (macOS)
    // The webview can silently lose focus, making the entire UI unresponsive
    // to keyboard and sometimes mouse input. Detect and recover by refocusing.
    const callNativeFocusRecovery = () => {
      // Call the Rust-side ensure_webview_focus to re-assert WKWebView
      // as first responder via makeFirstResponder + dispatch_async
      try {
        (window as any).__TAURI_INTERNALS__?.invoke("ensure_webview_focus").catch(() => {});
      } catch {}
    };

    const handleWindowFocus = () => {
      // When the native window regains focus, ensure the webview body is focused
      // so keyboard events work. Small delay to let Tauri finish its focus cycle.
      setTimeout(() => {
        if (document.activeElement === document.body || !document.activeElement) {
          document.body.focus();
        }
        callNativeFocusRecovery();
      }, 50);
    };
    window.addEventListener("focus", handleWindowFocus);

    // Safety valve: click on the app background to force-dismiss stuck overlays
    // by blurring and refocusing — helps when overlays block normal interaction
    const handlePointerRecovery = () => {
      // If there are any fixed z-50 overlays that shouldn't be there,
      // force focus back to body to recover keyboard input
      if (document.activeElement === document.body || !document.activeElement) {
        document.body.tabIndex = -1;
        document.body.focus();
      }
    };
    // Re-check focus on any click — if click reaches window, focus should work
    window.addEventListener("mousedown", handlePointerRecovery, true);

    // Periodic focus watchdog: detect silent focus loss that no event catches.
    // WKWebView can lose first-responder status without firing any JS event
    // (e.g. after native dialog dismiss, tray interaction, or AppKit race).
    // Every 2s, test if a keystroke would reach the webview by checking if
    // the document can receive input. If not, trigger native recovery.
    let lastKeyTime = Date.now();
    const markKeyActivity = () => { lastKeyTime = Date.now(); };
    window.addEventListener("keydown", markKeyActivity, true);

    const focusWatchdog = setInterval(() => {
      // Only check when the window is visible and focused
      if (document.hidden || !document.hasFocus()) return;
      // If we haven't seen a keystroke in 10s and the active element is body
      // (not an input), something may be wrong — but don't interfere if user
      // is just using the mouse. Only recover if user recently clicked (mouse
      // activity without keyboard suggests potential stuck state).
      const now = Date.now();
      const noRecentKeys = now - lastKeyTime > 10_000;
      const activeIsBody = document.activeElement === document.body || !document.activeElement;
      if (noRecentKeys && activeIsBody) {
        callNativeFocusRecovery();
      }
    }, 2_000);

    // Auto-reload on IndexedDB disconnect (APP-2E, 27 users on v2.0.379)
    // WKWebView's IndexedDB server can crash; the page becomes unusable.
    // PostHog JS SDK uses IndexedDB for session replay — this is a known WebKit bug.
    let idbReloadPending = false;
    const handleUnhandledRejection = (e: PromiseRejectionEvent) => {
      const msg = String(e.reason?.message || e.reason || "");
      if (msg.includes("Connection to Indexed Database server lost")) {
        // Prevent the error from reaching Sentry — we handle it via reload
        e.preventDefault();
        if (idbReloadPending) return; // debounce: only one reload
        idbReloadPending = true;
        console.warn("IndexedDB server lost — reloading page in 1s");
        // Short delay to let any in-flight operations settle
        setTimeout(() => window.location.reload(), 1000);
      }
    };
    window.addEventListener("unhandledrejection", handleUnhandledRejection);

    const logs: string[] = [];
    const MAX_LOGS = 1000;
    const originalConsole = { ...console };
    const debouncedWrite = createDebouncer(1000);

    ["log", "error", "warn", "info"].forEach((level) => {
      (console[level as keyof Console] as any) = (...args: any[]) => {
        // Call original first for performance
        (originalConsole[level as keyof Console] as Function)(...args);

        // Add to memory buffer
        logs.push(
          `[${level.toUpperCase()}] ${args
            .map((arg) => (typeof arg === "object" ? JSON.stringify(arg) : arg))
            .join(" ")}`
        );

        // Trim buffer if needed
        if (logs.length > MAX_LOGS) {
          logs.splice(0, logs.length - MAX_LOGS);
        }

        // Debounced write to localStorage
        debouncedWrite(() => {
          try {
            // localStorage can be null in Tauri WKWebView during navigation
            if (!localStorage) return;
            localStorage.setItem("console_logs", logs.join("\n"));
          } catch (e) {
            try {
              // If localStorage is full, clear half the logs
              logs.splice(0, logs.length / 2);
              if (localStorage) localStorage.setItem("console_logs", logs.join("\n"));
            } catch {
              // localStorage unavailable, skip silently
            }
          }
        });
      };
    });

    return () => {
      window.removeEventListener("focus", handleWindowFocus);
      window.removeEventListener("mousedown", handlePointerRecovery, true);
      window.removeEventListener("keydown", markKeyActivity, true);
      window.removeEventListener("unhandledrejection", handleUnhandledRejection);
      clearInterval(focusWatchdog);
    };
  }, []);

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                try {
                  var theme = localStorage.getItem('screenpipe-ui-theme');
                  if (!theme) {
                    theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                  }
                  document.documentElement.classList.add(theme);
                } catch (e) {
                  document.documentElement.classList.add('light');
                }
              })();
            `,
          }}
        />
      </head>
      <Providers>
        <body className={`${inter.className} scrollbar-hide`}>
          {!isOverlay && <DeeplinkHandler />}
          {!isOverlay && <ShortcutTracker />}
          {children}
          {!isOverlay && <Toaster />}
        </body>
      </Providers>
    </html>
  );
}
